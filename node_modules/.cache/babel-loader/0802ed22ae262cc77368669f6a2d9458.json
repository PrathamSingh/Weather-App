{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nfunction _helperGetFunctionArity() {\n  const data = _interopRequireDefault(require(\"@babel/helper-get-function-arity\"));\n\n  _helperGetFunctionArity = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = _interopRequireDefault(require(\"@babel/template\"));\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst buildPropertyMethodAssignmentWrapper = (0, _template().default)(\"\\n  (function (FUNCTION_KEY) {\\n    function FUNCTION_ID() {\\n      return FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    }\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\nconst buildGeneratorPropertyMethodAssignmentWrapper = (0, _template().default)(\"\\n  (function (FUNCTION_KEY) {\\n    function* FUNCTION_ID() {\\n      return yield* FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    };\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (t().isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (t().isRegExpLiteral(id)) {\n    return \"_\".concat(id.pattern, \"_\").concat(id.flags);\n  }\n\n  if (t().isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!t().isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = (0, _helperGetFunctionArity().default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default({\n  node,\n  parent,\n  scope,\n  id\n}, localBinding = false) {\n  if (node.id) return;\n\n  if ((t().isObjectProperty(parent) || t().isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || t().isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (t().isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (t().isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = t().cloneNode(id);\n        node.id[t().NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (t().isAssignmentExpression(parent)) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && t().isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && t().isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  name = t().toBindingIdentifierName(name);\n  id = t().identifier(name);\n  id[t().NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n}","map":null,"metadata":{},"sourceType":"script"}